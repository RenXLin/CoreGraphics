//
//  StyleKitName.m
//  ProjectName
//
//  Created by AuthorName on 14/11/3.
//  Copyright (c) 2014 CompanyName. All rights reserved.
//
//  Generated by PaintCode (www.paintcodeapp.com)
//

#import "StyleKit.h"


@implementation StyleKit

#pragma mark Initialization

+ (void)initialize
{
}

//// In trial version of PaintCode, the code generation is limited to one canvas

#pragma mark Drawing Methods

//// PaintCode Trial Version
//// www.paintcodeapp.com

+ (void)drawCanvas1:(CGFloat)progress
{
    //// Color Declarations
    UIColor* color = [UIColor colorWithRed: 0.71 green: 0.181 blue: 0.181 alpha: 1];
    UIColor* color2 = [UIColor colorWithRed: 0.265 green: 0.313 blue: 0.752 alpha: 1];
    UIColor* color3 = [UIColor colorWithRed: 0.354 green: 0.772 blue: 0.48 alpha: 1];
    
    //// Rectangle Drawing
    UIBezierPath* rectanglePath = [UIBezierPath bezierPathWithRoundedRect: CGRectMake(0, 0, 182, 81) cornerRadius: 9];
    [UIColor.grayColor setFill];
    [rectanglePath fill];
    
    
    //// Star Drawing
    UIBezierPath* starPath = UIBezierPath.bezierPath;
    [starPath moveToPoint: CGPointMake(24, 10)];
    [starPath addLineToPoint: CGPointMake(30, 15.15)];
    [starPath addLineToPoint: CGPointMake(40.17, 16.91)];
    [starPath addLineToPoint: CGPointMake(33.7, 21.85)];
    [starPath addLineToPoint: CGPointMake(33.99, 28.09)];
    [starPath addLineToPoint: CGPointMake(24, 26)];
    [starPath addLineToPoint: CGPointMake(14.01, 28.09)];
    [starPath addLineToPoint: CGPointMake(14.3, 21.85)];
    [starPath addLineToPoint: CGPointMake(7.83, 16.91)];
    [starPath addLineToPoint: CGPointMake(18, 15.15)];
    [starPath closePath];
    [color setFill];
    [starPath fill];
    
    
    //// Bezier Drawing
    UIBezierPath* bezierPath = UIBezierPath.bezierPath;
    [bezierPath moveToPoint: CGPointMake(78.77, 12.92)];
    [bezierPath addLineToPoint: CGPointMake(51.77, 29.92)];
    [bezierPath addLineToPoint: CGPointMake(51.61, 29.01)];
    [bezierPath addLineToPoint: CGPointMake(99.61, 40.01)];
    [bezierPath addLineToPoint: CGPointMake(99.1, 40.8)];
    [bezierPath addLineToPoint: CGPointMake(78.1, 12.8)];
    [bezierPath addLineToPoint: CGPointMake(78.77, 12.92)];
    [bezierPath closePath];
    [bezierPath moveToPoint: CGPointMake(78.23, 12.08)];
    [bezierPath addLineToPoint: CGPointMake(78.62, 11.83)];
    [bezierPath addLineToPoint: CGPointMake(78.9, 12.2)];
    [bezierPath addLineToPoint: CGPointMake(99.9, 40.2)];
    [bezierPath addLineToPoint: CGPointMake(100.72, 41.29)];
    [bezierPath addLineToPoint: CGPointMake(99.39, 40.99)];
    [bezierPath addLineToPoint: CGPointMake(51.39, 29.99)];
    [bezierPath addLineToPoint: CGPointMake(50.21, 29.72)];
    [bezierPath addLineToPoint: CGPointMake(51.23, 29.08)];
    [bezierPath addLineToPoint: CGPointMake(78.23, 12.08)];
    [bezierPath closePath];
    [color2 setFill];
    [bezierPath fill];
    
    
    //// Text Drawing
    CGRect textRect = CGRectMake(110, 10, 50, 50);
    NSMutableParagraphStyle* textStyle = NSMutableParagraphStyle.defaultParagraphStyle.mutableCopy;
    textStyle.alignment = NSTextAlignmentCenter;
    
    NSDictionary* textFontAttributes = @{NSFontAttributeName: [UIFont fontWithName: @"Helvetica" size: 12], NSForegroundColorAttributeName: UIColor.blackColor, NSParagraphStyleAttributeName: textStyle};
    
    [@"Hello, World!" drawInRect: textRect withAttributes: textFontAttributes];
    
    
    //// Oval Drawing
    CGRect ovalRect = CGRectMake(22, 34, 35, 31);
    UIBezierPath* ovalPath = UIBezierPath.bezierPath;
    [ovalPath addArcWithCenter: CGPointMake(0, 0) radius: CGRectGetWidth(ovalRect) / 2 startAngle: 0 * M_PI/180 endAngle: 360*progress * M_PI/180 clockwise: YES];
    [ovalPath addLineToPoint: CGPointMake(0, 0)];
    [ovalPath closePath];
    
    CGAffineTransform ovalTransform = CGAffineTransformMakeTranslation(CGRectGetMidX(ovalRect), CGRectGetMidY(ovalRect));
    ovalTransform = CGAffineTransformScale(ovalTransform, 1, CGRectGetHeight(ovalRect) / CGRectGetWidth(ovalRect));
    [ovalPath applyTransform: ovalTransform];
    
    [color3 setFill];
    [ovalPath fill];
    [color2 setStroke];
    ovalPath.lineWidth = 2;
    [ovalPath stroke];
    
    NSString* textContent = @"0%";
    textStyle = NSMutableParagraphStyle.defaultParagraphStyle.mutableCopy;
    textStyle.alignment = NSTextAlignmentCenter;
    
    textFontAttributes = @{NSFontAttributeName: [UIFont fontWithName: @"Helvetica" size: 12], NSForegroundColorAttributeName: UIColor.blackColor, NSParagraphStyleAttributeName: textStyle};
    
    [textContent drawInRect: CGRectOffset(textRect, 0, (CGRectGetHeight(textRect) - [textContent boundingRectWithSize: textRect.size options: NSStringDrawingUsesLineFragmentOrigin attributes: textFontAttributes context: nil].size.height) / 2) withAttributes: textFontAttributes];

    // Trial version of PaintCode only generates code for the first 5 shapes.
}

+(void)drawCanves2:(CGFloat)pressure
{
    //// General Declarations
    //// General Declarations
    CGContextRef context = UIGraphicsGetCurrentContext();
    
    //// Color Declarations
    UIColor* strokeColor = [UIColor colorWithRed: 0.437 green: 0.437 blue: 0.437 alpha: 1];
    UIColor* highPressureColor = [UIColor colorWithRed: 0.8 green: 0.32 blue: 0.32 alpha: 1];
    UIColor* lowPressureColor = [UIColor colorWithRed: 0.652 green: 0.8 blue: 0.32 alpha: 1];
    
    //// Variable Declarations
    CGFloat angle = -240 * pressure;
    UIColor* limitingColor = pressure > 0.7 ? highPressureColor : lowPressureColor;
    
    //// Outer Frame Drawing
    UIBezierPath* outerFramePath = [UIBezierPath bezierPathWithOvalInRect: CGRectMake(37, 27, 100, 100)];
    [UIColor.whiteColor setFill];
    [outerFramePath fill];
    [strokeColor setStroke];
    outerFramePath.lineWidth = 2;
    [outerFramePath stroke];
    
    
    //// Scale Frame Drawing
    UIBezierPath* scaleFramePath = UIBezierPath.bezierPath;
    [scaleFramePath moveToPoint: CGPointMake(51.49, 97.5)];
    [scaleFramePath addCurveToPoint: CGPointMake(66.5, 41.49) controlPoint1: CGPointMake(40.17, 77.89) controlPoint2: CGPointMake(46.89, 52.81)];
    [scaleFramePath addCurveToPoint: CGPointMake(122.51, 56.5) controlPoint1: CGPointMake(86.11, 30.17) controlPoint2: CGPointMake(111.19, 36.89)];
    [scaleFramePath addCurveToPoint: CGPointMake(122.51, 97.5) controlPoint1: CGPointMake(129.83, 69.19) controlPoint2: CGPointMake(129.83, 84.81)];
    [scaleFramePath addLineToPoint: CGPointMake(110.38, 90.5)];
    [scaleFramePath addCurveToPoint: CGPointMake(110.38, 63.5) controlPoint1: CGPointMake(115.21, 82.15) controlPoint2: CGPointMake(115.21, 71.85)];
    [scaleFramePath addCurveToPoint: CGPointMake(73.5, 53.62) controlPoint1: CGPointMake(102.93, 50.59) controlPoint2: CGPointMake(86.41, 46.16)];
    [scaleFramePath addCurveToPoint: CGPointMake(63.62, 90.5) controlPoint1: CGPointMake(60.59, 61.07) controlPoint2: CGPointMake(56.16, 77.59)];
    [scaleFramePath addLineToPoint: CGPointMake(51.49, 97.5)];
    [scaleFramePath closePath];
    [strokeColor setStroke];
    scaleFramePath.lineWidth = 2;
    [scaleFramePath stroke];
    
    
    //// Display Drawing
    UIBezierPath* displayPath = UIBezierPath.bezierPath;
    [displayPath moveToPoint: CGPointMake(103.02, 114.74)];
    [displayPath addCurveToPoint: CGPointMake(70.98, 114.74) controlPoint1: CGPointMake(92.78, 119.09) controlPoint2: CGPointMake(81.22, 119.09)];
    [displayPath addLineToPoint: CGPointMake(73.72, 108.3)];
    [displayPath addCurveToPoint: CGPointMake(100.28, 108.3) controlPoint1: CGPointMake(82.21, 111.9) controlPoint2: CGPointMake(91.79, 111.9)];
    [displayPath addLineToPoint: CGPointMake(103.02, 114.74)];
    [displayPath closePath];
    [limitingColor setFill];
    [displayPath fill];
    [strokeColor setStroke];
    displayPath.lineWidth = 2;
    [displayPath stroke];
    
    
    //// Bezier Drawing
    UIBezierPath* bezierPath = UIBezierPath.bezierPath;
    [bezierPath moveToPoint: CGPointMake(87, 43)];
    [bezierPath addLineToPoint: CGPointMake(87, 36)];
    [bezierPath moveToPoint: CGPointMake(46, 77)];
    [bezierPath addLineToPoint: CGPointMake(53, 77)];
    [bezierPath moveToPoint: CGPointMake(121, 77)];
    [bezierPath addLineToPoint: CGPointMake(128, 77)];
    [bezierPath moveToPoint: CGPointMake(111.04, 52.96)];
    [bezierPath addLineToPoint: CGPointMake(115.99, 48.01)];
    [bezierPath moveToPoint: CGPointMake(58.01, 48.01)];
    [bezierPath addLineToPoint: CGPointMake(62.96, 52.96)];
    [bezierPath moveToPoint: CGPointMake(118.41, 63.99)];
    [bezierPath addLineToPoint: CGPointMake(124.88, 61.31)];
    [bezierPath moveToPoint: CGPointMake(49.12, 61.31)];
    [bezierPath addLineToPoint: CGPointMake(55.59, 63.99)];
    [bezierPath moveToPoint: CGPointMake(71.31, 39.12)];
    [bezierPath addLineToPoint: CGPointMake(73.99, 45.59)];
    [bezierPath moveToPoint: CGPointMake(100.01, 108.41)];
    [bezierPath addLineToPoint: CGPointMake(102.69, 114.88)];
    [bezierPath moveToPoint: CGPointMake(102.69, 39.12)];
    [bezierPath addLineToPoint: CGPointMake(100.01, 45.59)];
    [bezierPath moveToPoint: CGPointMake(73.99, 108.41)];
    [bezierPath addLineToPoint: CGPointMake(71.31, 114.88)];
    [strokeColor setStroke];
    bezierPath.lineWidth = 2;
    [bezierPath stroke];
    
    
    //// Arrow Drawing
    //当有旋转的时候：需要使用该语句：
    CGContextSaveGState(context);
    //设置所绕旋转点坐标
    CGContextTranslateCTM(context, 87.01, 78);
    //旋转角度：
    CGContextRotateCTM(context, -(angle + 120) * M_PI / 180);
    
    UIBezierPath* arrowPath = UIBezierPath.bezierPath;
    [arrowPath moveToPoint: CGPointMake(-4, 14)];
    [arrowPath addLineToPoint: CGPointMake(-4, 5)];
    [arrowPath addLineToPoint: CGPointMake(-2.88, -5)];
    [arrowPath addLineToPoint: CGPointMake(-2.88, -33)];
    [arrowPath addLineToPoint: CGPointMake(0.49, -37)];
    [arrowPath addLineToPoint: CGPointMake(3.85, -33)];
    [arrowPath addLineToPoint: CGPointMake(3.85, -5)];
    [arrowPath addLineToPoint: CGPointMake(4.97, 5)];
    [arrowPath addLineToPoint: CGPointMake(4.97, 14)];
    [arrowPath addLineToPoint: CGPointMake(-4, 14)];
    [arrowPath closePath];
    arrowPath.lineJoinStyle = kCGLineJoinRound;
    
    [strokeColor setFill];
    [arrowPath fill];
    [strokeColor setStroke];
    arrowPath.lineWidth = 2;
    [arrowPath stroke];
    
    CGContextRestoreGState(context);
    
    CGContextClosePath(context);
}

@end
